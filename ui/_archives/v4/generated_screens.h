#pragma once

// Auto-generated by mercure_ui UI designer.
// Target: 128x64 SSD1306 using Adafruit_SSD1306 + Adafruit_GFX.
// NOTE: draw_*_screen() functions do NOT call display.display().
// Call display.display() once per frame after draw_screen(...).

#include <Arduino.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

static const uint8_t UI_DESIGNER_W = 128;
static const uint8_t UI_DESIGNER_H = 64;

// Available screens (auto-generated).
enum class UiScreen : uint8_t {
  LOADING = 0,
  BOOT = 1,
  FIND_POSITION = 2,
  MOVE_CLOSER = 3,
  MOVE_FARTHER = 4,
  IN_POSITION = 5,
  CALIBRATION = 6,
  RECORD_CONFIRMATION = 7,
  RECORDING = 8,
  STOP_RECORD = 9,
  INFERENCE_LOADING = 10,
  RESULTS = 11,
  MONITORING = 12,
};

// Dynamic element variables (auto-generated).
// Update these values at runtime before calling draw_*_screen() / draw_screen().
static String ui_loading_data = "{Metadata}";
static bool ui_tracker_detected = false;
static bool ui_led_detected = false;
static bool ui_connection = false;
static String ui_text_el_194 = "Calibration>";
static String ui_calib_start_btn = "Start calibration>";
static String ui_calib_next_btn = "";
static String ui_calib_redo_btn = "";
static String ui_calib_result = "";
static String ui_recording_timer = "02:23";
static String ui_event_time = "00:24";
static String ui_event_name = "STOP EVENT 3";
static String ui_close_event_warning = "Event marker 29 will\nbe closed\nautomatically";
static String ui_inference_timer = "02:34";
static uint8_t ui_inference_prog_bar = 0;  // 0..100
static String ui_results_title = "GLOBAL RESULTS";
static String ui_results_next_btn = "Next>";
static String ui_result_1 = "TEXT";
static String ui_result_2 = "TEXT";
static String ui_result_3 = "TEXT";
static String ui_result_4 = "TEXT";
static String ui_results_prev_btn = "<Previous";
static String ui_text_el_269 = "Good";

// Extra dynamic booleans used by the host app (added post-generation).
static bool ui_led_up_left = false;
static bool ui_led_up_right = false;
static bool ui_led_bottom_left = false;
static bool ui_led_bottom_right = false;
static bool ui_left_eye = false;
static bool ui_right_eye = false;
static uint8_t ui_gaze_x = 128;  // 0..255
static uint8_t ui_gaze_y = 128;  // 0..255

// Dynamic variables (auto-generated).
enum class UiDynamicVar : uint8_t {
  UI_LOADING_DATA,
  UI_TRACKER_DETECTED,
  UI_LED_DETECTED,
  UI_CONNECTION,
  UI_TEXT_EL_194,
  UI_CALIB_START_BTN,
  UI_CALIB_NEXT_BTN,
  UI_CALIB_REDO_BTN,
  UI_CALIB_RESULT,
  UI_RECORDING_TIMER,
  UI_EVENT_TIME,
  UI_EVENT_NAME,
  UI_CLOSE_EVENT_WARNING,
  UI_INFERENCE_TIMER,
  UI_INFERENCE_PROG_BAR,
  UI_RESULTS_TITLE,
  UI_RESULTS_NEXT_BTN,
  UI_RESULT_1,
  UI_RESULT_2,
  UI_RESULT_3,
  UI_RESULT_4,
  UI_RESULTS_PREV_BTN,
  UI_TEXT_EL_269,
  UI_LED_UP_LEFT,
  UI_LED_UP_RIGHT,
  UI_LED_BOTTOM_LEFT,
  UI_LED_BOTTOM_RIGHT,
  UI_LEFT_EYE,
  UI_RIGHT_EYE,
  UI_GAZE_X,
  UI_GAZE_Y,
};

// Generic fallback: unknown types/vars return default and do nothing.
template <typename T> inline T ui_get(UiDynamicVar) { return T(); }
template <typename T> inline void ui_set(UiDynamicVar, const T &) {}

template <> inline bool ui_get<bool>(UiDynamicVar var) {
  switch (var) {
    case UiDynamicVar::UI_TRACKER_DETECTED: return ui_tracker_detected;
    case UiDynamicVar::UI_LED_DETECTED: return ui_led_detected;
    case UiDynamicVar::UI_CONNECTION: return ui_connection;
    case UiDynamicVar::UI_LED_UP_LEFT: return ui_led_up_left;
    case UiDynamicVar::UI_LED_UP_RIGHT: return ui_led_up_right;
    case UiDynamicVar::UI_LED_BOTTOM_LEFT: return ui_led_bottom_left;
    case UiDynamicVar::UI_LED_BOTTOM_RIGHT: return ui_led_bottom_right;
    case UiDynamicVar::UI_LEFT_EYE: return ui_left_eye;
    case UiDynamicVar::UI_RIGHT_EYE: return ui_right_eye;
    default: return false;
  }
}
template <> inline void ui_set<bool>(UiDynamicVar var, const bool &value) {
  switch (var) {
    case UiDynamicVar::UI_TRACKER_DETECTED: ui_tracker_detected = value; break;
    case UiDynamicVar::UI_LED_DETECTED: ui_led_detected = value; break;
    case UiDynamicVar::UI_CONNECTION: ui_connection = value; break;
    case UiDynamicVar::UI_LED_UP_LEFT: ui_led_up_left = value; break;
    case UiDynamicVar::UI_LED_UP_RIGHT: ui_led_up_right = value; break;
    case UiDynamicVar::UI_LED_BOTTOM_LEFT: ui_led_bottom_left = value; break;
    case UiDynamicVar::UI_LED_BOTTOM_RIGHT: ui_led_bottom_right = value; break;
    case UiDynamicVar::UI_LEFT_EYE: ui_left_eye = value; break;
    case UiDynamicVar::UI_RIGHT_EYE: ui_right_eye = value; break;
    default: break;
  }
}

template <> inline uint8_t ui_get<uint8_t>(UiDynamicVar var) {
  switch (var) {
    case UiDynamicVar::UI_INFERENCE_PROG_BAR: return ui_inference_prog_bar;
    case UiDynamicVar::UI_GAZE_X: return ui_gaze_x;
    case UiDynamicVar::UI_GAZE_Y: return ui_gaze_y;
    default: return 0;
  }
}
template <> inline void ui_set<uint8_t>(UiDynamicVar var, const uint8_t &value) {
  switch (var) {
    case UiDynamicVar::UI_INFERENCE_PROG_BAR: ui_inference_prog_bar = value; break;
    case UiDynamicVar::UI_GAZE_X: ui_gaze_x = value; break;
    case UiDynamicVar::UI_GAZE_Y: ui_gaze_y = value; break;
    default: break;
  }
}

template <> inline String ui_get<String>(UiDynamicVar var) {
  switch (var) {
    case UiDynamicVar::UI_LOADING_DATA: return ui_loading_data;
    case UiDynamicVar::UI_TEXT_EL_194: return ui_text_el_194;
    case UiDynamicVar::UI_CALIB_START_BTN: return ui_calib_start_btn;
    case UiDynamicVar::UI_CALIB_NEXT_BTN: return ui_calib_next_btn;
    case UiDynamicVar::UI_CALIB_REDO_BTN: return ui_calib_redo_btn;
    case UiDynamicVar::UI_CALIB_RESULT: return ui_calib_result;
    case UiDynamicVar::UI_RECORDING_TIMER: return ui_recording_timer;
    case UiDynamicVar::UI_EVENT_TIME: return ui_event_time;
    case UiDynamicVar::UI_EVENT_NAME: return ui_event_name;
    case UiDynamicVar::UI_CLOSE_EVENT_WARNING: return ui_close_event_warning;
    case UiDynamicVar::UI_INFERENCE_TIMER: return ui_inference_timer;
    case UiDynamicVar::UI_RESULTS_TITLE: return ui_results_title;
    case UiDynamicVar::UI_RESULTS_NEXT_BTN: return ui_results_next_btn;
    case UiDynamicVar::UI_RESULT_1: return ui_result_1;
    case UiDynamicVar::UI_RESULT_2: return ui_result_2;
    case UiDynamicVar::UI_RESULT_3: return ui_result_3;
    case UiDynamicVar::UI_RESULT_4: return ui_result_4;
    case UiDynamicVar::UI_RESULTS_PREV_BTN: return ui_results_prev_btn;
    case UiDynamicVar::UI_TEXT_EL_269: return ui_text_el_269;
    default: return String("");
  }
}
template <> inline void ui_set<String>(UiDynamicVar var, const String &value) {
  // Preserve line breaks when host sends escaped sequences like "\\n".
  // This makes it safe to set dynamic text from serial protocols that cannot
  // transmit raw newlines easily.
  String v = value;
  v.replace("\\n", "\n");
  v.replace("\\r", "\r");
  switch (var) {
    case UiDynamicVar::UI_LOADING_DATA: ui_loading_data = v; break;
    case UiDynamicVar::UI_TEXT_EL_194: ui_text_el_194 = v; break;
    case UiDynamicVar::UI_CALIB_START_BTN: ui_calib_start_btn = v; break;
    case UiDynamicVar::UI_CALIB_NEXT_BTN: ui_calib_next_btn = v; break;
    case UiDynamicVar::UI_CALIB_REDO_BTN: ui_calib_redo_btn = v; break;
    case UiDynamicVar::UI_CALIB_RESULT: ui_calib_result = v; break;
    case UiDynamicVar::UI_RECORDING_TIMER: ui_recording_timer = v; break;
    case UiDynamicVar::UI_EVENT_TIME: ui_event_time = v; break;
    case UiDynamicVar::UI_EVENT_NAME: ui_event_name = v; break;
    case UiDynamicVar::UI_CLOSE_EVENT_WARNING: ui_close_event_warning = v; break;
    case UiDynamicVar::UI_INFERENCE_TIMER: ui_inference_timer = v; break;
    case UiDynamicVar::UI_RESULTS_TITLE: ui_results_title = v; break;
    case UiDynamicVar::UI_RESULTS_NEXT_BTN: ui_results_next_btn = v; break;
    case UiDynamicVar::UI_RESULT_1: ui_result_1 = v; break;
    case UiDynamicVar::UI_RESULT_2: ui_result_2 = v; break;
    case UiDynamicVar::UI_RESULT_3: ui_result_3 = v; break;
    case UiDynamicVar::UI_RESULT_4: ui_result_4 = v; break;
    case UiDynamicVar::UI_RESULTS_PREV_BTN: ui_results_prev_btn = v; break;
    case UiDynamicVar::UI_TEXT_EL_269: ui_text_el_269 = v; break;
    default: break;
  }
}

// Screen 0: loading
inline void draw_loading_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  // PLACEHOLDER region: x=52, y=23, w=24, h=23
  // TODO: add custom drawing code here
  // Example: display.drawBitmap(...);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_loading_data.length(); i++) {
      const char ch = ui_loading_data[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 51;
    size_t i = 0;
    while (i <= ui_loading_data.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_loading_data.length()) {
        const char ch = ui_loading_data[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 34;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_loading_data.length()) {
        const char ch = ui_loading_data[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_loading_data.length()) break;
      // Newline.
      if (ui_loading_data[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(42, 3);
  display.print(F("LOADING,"));
  display.setCursor(24, 11);
  display.print(F("PLEASE WAIT..."));
}

// Screen 1: boot
inline void draw_boot_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.drawRect(8, 21, 8, 8, SSD1306_WHITE);
  if (ui_tracker_detected) {
    display.drawLine(10, 25, 10, 26, SSD1306_WHITE);
    display.drawLine(10, 26, 13, 23, SSD1306_WHITE);
  }
  display.drawRect(8, 31, 8, 8, SSD1306_WHITE);
  if (ui_led_detected) {
    display.drawLine(10, 35, 10, 36, SSD1306_WHITE);
    display.drawLine(10, 36, 13, 33, SSD1306_WHITE);
  }
  display.drawRect(8, 41, 8, 8, SSD1306_WHITE);
  if (ui_connection) {
    display.drawLine(10, 45, 10, 46, SSD1306_WHITE);
    display.drawLine(10, 46, 13, 43, SSD1306_WHITE);
  }
  // PLACEHOLDER region: x=15, y=53, w=10, h=10
  // TODO: add custom drawing code here
  // Example: display.drawBitmap(...);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(19, 21);
  display.print(F("Eye tracker"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(19, 31);
  display.print(F("LED"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(19, 41);
  display.print(F("Connection"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(43, 5);
  display.print(F("LOADING"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_loading_data.length(); i++) {
      const char ch = ui_loading_data[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 54;
    size_t i = 0;
    while (i <= ui_loading_data.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_loading_data.length()) {
        const char ch = ui_loading_data[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 26;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_loading_data.length()) {
        const char ch = ui_loading_data[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_loading_data.length()) break;
      // Newline.
      if (ui_loading_data[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(92, 54);
  display.print(F("Start>"));
}

// Screen 2: find_position
inline void draw_find_position_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.drawLine(0, 11, 127, 11, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(3, 2);
  display.print(F("POSITION SUBJECT"));
  display.drawRoundRect(19, 16, 41, 16, 3, SSD1306_WHITE);
  {
    const int x1 = 19, y1 = 35, x2 = 61, y2 = 36;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  {
    const int x1 = 16, y1 = 60, x2 = 22, y2 = 36;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  {
    const int x1 = 56, y1 = 35, x2 = 62, y2 = 59;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  {
    const int x1 = 14, y1 = 57, x2 = 65, y2 = 58;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  display.drawCircle(39, 46, 8, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(90, 54);
  display.print(F("Start>"));
}

// Screen 3: move_closer
inline void draw_move_closer_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.drawLine(0, 11, 127, 11, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(3, 2);
  display.print(F("HEAD POSITION"));
  display.drawRoundRect(7, 17, 41, 16, 3, SSD1306_WHITE);
  {
    const int x1 = 7, y1 = 36, x2 = 49, y2 = 37;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  {
    const int x1 = 6, y1 = 59, x2 = 12, y2 = 35;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  {
    const int x1 = 43, y1 = 35, x2 = 49, y2 = 59;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  {
    const int x1 = 3, y1 = 58, x2 = 54, y2 = 59;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  display.drawCircle(28, 54, 8, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(72, 36);
  display.print(F("PLEASE"));
  display.setCursor(57, 44);
  display.print(F("MOVE CLOSER"));
  display.drawTriangle(90, 22, 84, 32, 95, 32, SSD1306_WHITE);
  display.drawLine(90, 25, 90, 28, SSD1306_WHITE);
  display.fillRect(89, 30, 2, 2, SSD1306_WHITE);
}

// Screen 4: move_farther
inline void draw_move_farther_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.drawLine(0, 11, 127, 11, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(3, 2);
  display.print(F("HEAD POSITION"));
  display.drawRoundRect(7, 17, 41, 16, 3, SSD1306_WHITE);
  {
    const int x1 = 7, y1 = 36, x2 = 49, y2 = 37;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  {
    const int x1 = 6, y1 = 59, x2 = 12, y2 = 35;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  {
    const int x1 = 43, y1 = 35, x2 = 49, y2 = 59;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  {
    const int x1 = 3, y1 = 58, x2 = 54, y2 = 59;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  display.drawCircle(28, 41, 8, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(73, 36);
  display.print(F("PLEASE"));
  display.setCursor(55, 44);
  display.print(F("MOVE FARTHER"));
  display.drawTriangle(90, 22, 84, 32, 95, 32, SSD1306_WHITE);
  display.drawLine(90, 25, 90, 28, SSD1306_WHITE);
  display.fillRect(89, 30, 2, 2, SSD1306_WHITE);
}

// Screen 5: in_position
inline void draw_in_position_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.drawLine(0, 11, 127, 11, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(3, 2);
  display.print(F("HEAD POSITION"));
  display.drawRoundRect(7, 17, 41, 16, 3, SSD1306_WHITE);
  {
    const int x1 = 7, y1 = 36, x2 = 49, y2 = 37;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  {
    const int x1 = 6, y1 = 59, x2 = 12, y2 = 35;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  {
    const int x1 = 43, y1 = 35, x2 = 49, y2 = 59;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  {
    const int x1 = 3, y1 = 58, x2 = 54, y2 = 59;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  display.drawCircle(28, 48, 8, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(63, 32);
  display.print(F("YOU'RE IN"));
  display.setCursor(66, 40);
  display.print(F("POSITION"));
  display.drawCircle(89, 23, 6, SSD1306_WHITE);
  display.drawLine(86, 23, 88, 25, SSD1306_WHITE);
  display.drawLine(88, 25, 92, 21, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_text_el_194.length(); i++) {
      const char ch = ui_text_el_194[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 54;
    size_t i = 0;
    while (i <= ui_text_el_194.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_text_el_194.length()) {
        const char ch = ui_text_el_194[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 55;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_text_el_194.length()) {
        const char ch = ui_text_el_194[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_text_el_194.length()) break;
      // Newline.
      if (ui_text_el_194[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
}

// Screen 6: calibration
inline void draw_calibration_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_calib_start_btn.length(); i++) {
      const char ch = ui_calib_start_btn[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 55;
    size_t i = 0;
    while (i <= ui_calib_start_btn.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_calib_start_btn.length()) {
        const char ch = ui_calib_start_btn[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 19;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_calib_start_btn.length()) {
        const char ch = ui_calib_start_btn[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_calib_start_btn.length()) break;
      // Newline.
      if (ui_calib_start_btn[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  // Corner indicators (host-driven).
  display.drawCircle(7, 7, 5, SSD1306_WHITE);     if (ui_led_up_left) display.fillCircle(7, 7, 2, SSD1306_WHITE);
  display.drawCircle(120, 7, 5, SSD1306_WHITE);   if (ui_led_up_right) display.fillCircle(120, 7, 2, SSD1306_WHITE);
  display.drawCircle(120, 45, 5, SSD1306_WHITE);  if (ui_led_bottom_right) display.fillCircle(120, 45, 2, SSD1306_WHITE);
  display.drawCircle(8, 45, 5, SSD1306_WHITE);    if (ui_led_bottom_left) display.fillCircle(8, 45, 2, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_calib_next_btn.length(); i++) {
      const char ch = ui_calib_next_btn[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 55;
    size_t i = 0;
    while (i <= ui_calib_next_btn.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_calib_next_btn.length()) {
        const char ch = ui_calib_next_btn[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 97;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_calib_next_btn.length()) {
        const char ch = ui_calib_next_btn[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_calib_next_btn.length()) break;
      // Newline.
      if (ui_calib_next_btn[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_calib_redo_btn.length(); i++) {
      const char ch = ui_calib_redo_btn[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 55;
    size_t i = 0;
    while (i <= ui_calib_redo_btn.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_calib_redo_btn.length()) {
        const char ch = ui_calib_redo_btn[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 3;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_calib_redo_btn.length()) {
        const char ch = ui_calib_redo_btn[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_calib_redo_btn.length()) break;
      // Newline.
      if (ui_calib_redo_btn[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(2);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 2;
    int lines_n = 1;
    for (size_t i = 0; i < ui_calib_result.length(); i++) {
      const char ch = ui_calib_result[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    const int oy = max(0, (21 - (lines_n * line_h)) / 2);
    int cy = 16 + oy;
    size_t i = 0;
    while (i <= ui_calib_result.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_calib_result.length()) {
        const char ch = ui_calib_result[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 25 + max(0, (77 - (cols * 6 * 2)) / 2);
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_calib_result.length()) {
        const char ch = ui_calib_result[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_calib_result.length()) break;
      // Newline.
      if (ui_calib_result[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
}

// Screen 7: record_confirmation
inline void draw_record_confirmation_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(14, 23);
  display.print(F("READY TO RECORD?"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(89, 54);
  display.print(F("Start>"));
}

// Screen 8: recording
inline void draw_recording_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.drawLine(0, 11, 127, 11, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(3, 2);
  display.print(F("RECORDING..."));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(36, 55);
  display.print(F("Stop recording>"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_recording_timer.length(); i++) {
      const char ch = ui_recording_timer[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 17;
    size_t i = 0;
    while (i <= ui_recording_timer.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_recording_timer.length()) {
        const char ch = ui_recording_timer[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 89;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_recording_timer.length()) {
        const char ch = ui_recording_timer[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_recording_timer.length()) break;
      // Newline.
      if (ui_recording_timer[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(9, 17);
  display.print(F("TOTAL TIME:"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(9, 27);
  display.print(F("EVENT TIME:"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_event_time.length(); i++) {
      const char ch = ui_event_time[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 27;
    size_t i = 0;
    while (i <= ui_event_time.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_event_time.length()) {
        const char ch = ui_event_time[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 89;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_event_time.length()) {
        const char ch = ui_event_time[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_event_time.length()) break;
      // Newline.
      if (ui_event_time[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_event_name.length(); i++) {
      const char ch = ui_event_name[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    const int oy = max(0, (8 - (lines_n * line_h)) / 2);
    int cy = 41 + oy;
    size_t i = 0;
    while (i <= ui_event_name.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_event_name.length()) {
        const char ch = ui_event_name[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 36 + max(0, (77 - (cols * 6 * 1)) / 2);
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_event_name.length()) {
        const char ch = ui_event_name[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_event_name.length()) break;
      // Newline.
      if (ui_event_name[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.drawCircle(25, 45, 6, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(23, 41);
  display.print(F("A"));
  display.drawRoundRect(13, 37, 101, 16, 3, SSD1306_WHITE);
}

// Screen 9: stop_record
inline void draw_stop_record_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(102, 55);
  display.print(F("Yes>"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(22, 16);
  display.print(F("End recording?"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(2, 55);
  display.print(F("<No"));
  display.drawLine(0, 11, 127, 11, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(3, 2);
  display.print(F("RECORDING..."));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_close_event_warning.length(); i++) {
      const char ch = ui_close_event_warning[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    const int oy = max(0, (30 - (lines_n * line_h)) / 2);
    int cy = 27 + oy;
    size_t i = 0;
    while (i <= ui_close_event_warning.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_close_event_warning.length()) {
        const char ch = ui_close_event_warning[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 0 + max(0, (128 - (cols * 6 * 1)) / 2);
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_close_event_warning.length()) {
        const char ch = ui_close_event_warning[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_close_event_warning.length()) break;
      // Newline.
      if (ui_close_event_warning[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
}

// Screen 10: inference_loading
inline void draw_inference_loading_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(34, 3);
  display.print(F("ANALYSING,"));
  display.setCursor(22, 11);
  display.print(F("PLEASE WAIT..."));
  // Progress bar outline + fill (0..100).
  display.drawRect(10, 28, 109, 5, SSD1306_WHITE);
  {
    const uint8_t pct = (ui_inference_prog_bar > 100) ? 100 : ui_inference_prog_bar;
    const int inner_w = 109 - 2;
    const int fill_w = (inner_w * int(pct)) / 100;
    if (fill_w > 0) {
      display.fillRect(11, 29, fill_w, 3, SSD1306_WHITE);
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_loading_data.length(); i++) {
      const char ch = ui_loading_data[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 53;
    size_t i = 0;
    while (i <= ui_loading_data.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_loading_data.length()) {
        const char ch = ui_loading_data[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 34;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_loading_data.length()) {
        const char ch = ui_loading_data[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_loading_data.length()) break;
      // Newline.
      if (ui_loading_data[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_inference_timer.length(); i++) {
      const char ch = ui_inference_timer[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 34;
    size_t i = 0;
    while (i <= ui_inference_timer.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_inference_timer.length()) {
        const char ch = ui_inference_timer[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 90;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_inference_timer.length()) {
        const char ch = ui_inference_timer[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_inference_timer.length()) break;
      // Newline.
      if (ui_inference_timer[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
}

// Screen 11: results
inline void draw_results_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.drawLine(0, 11, 127, 11, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_results_title.length(); i++) {
      const char ch = ui_results_title[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    const int oy = max(0, (9 - (lines_n * line_h)) / 2);
    int cy = 2 + oy;
    size_t i = 0;
    while (i <= ui_results_title.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_results_title.length()) {
        const char ch = ui_results_title[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 21 + max(0, (85 - (cols * 6 * 1)) / 2);
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_results_title.length()) {
        const char ch = ui_results_title[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_results_title.length()) break;
      // Newline.
      if (ui_results_title[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_results_next_btn.length(); i++) {
      const char ch = ui_results_next_btn[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 54;
    size_t i = 0;
    while (i <= ui_results_next_btn.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_results_next_btn.length()) {
        const char ch = ui_results_next_btn[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 96;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_results_next_btn.length()) {
        const char ch = ui_results_next_btn[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_results_next_btn.length()) break;
      // Newline.
      if (ui_results_next_btn[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_result_1.length(); i++) {
      const char ch = ui_result_1[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 19;
    size_t i = 0;
    while (i <= ui_result_1.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_result_1.length()) {
        const char ch = ui_result_1[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 4;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_result_1.length()) {
        const char ch = ui_result_1[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_result_1.length()) break;
      // Newline.
      if (ui_result_1[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_result_2.length(); i++) {
      const char ch = ui_result_2[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 19;
    size_t i = 0;
    while (i <= ui_result_2.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_result_2.length()) {
        const char ch = ui_result_2[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 64;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_result_2.length()) {
        const char ch = ui_result_2[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_result_2.length()) break;
      // Newline.
      if (ui_result_2[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_result_3.length(); i++) {
      const char ch = ui_result_3[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 35;
    size_t i = 0;
    while (i <= ui_result_3.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_result_3.length()) {
        const char ch = ui_result_3[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 3;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_result_3.length()) {
        const char ch = ui_result_3[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_result_3.length()) break;
      // Newline.
      if (ui_result_3[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_result_4.length(); i++) {
      const char ch = ui_result_4[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 35;
    size_t i = 0;
    while (i <= ui_result_4.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_result_4.length()) {
        const char ch = ui_result_4[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 64;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_result_4.length()) {
        const char ch = ui_result_4[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_result_4.length()) break;
      // Newline.
      if (ui_result_4[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_results_prev_btn.length(); i++) {
      const char ch = ui_results_prev_btn[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 55;
    size_t i = 0;
    while (i <= ui_results_prev_btn.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_results_prev_btn.length()) {
        const char ch = ui_results_prev_btn[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 2;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_results_prev_btn.length()) {
        const char ch = ui_results_prev_btn[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_results_prev_btn.length()) break;
      // Newline.
      if (ui_results_prev_btn[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
}

// Screen 12: monitoring
inline void draw_monitoring_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.drawLine(0, 11, 127, 11, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(33, 2);
  display.print(F("MONITORING"));
  display.drawRoundRect(57, 15, 69, 46, 3, SSD1306_WHITE);
  // Optional gaze dot (0..255 -> inside the rounded rect).
  {
    const int x0 = 57 + 3;
    const int y0 = 15 + 3;
    const int w = 69 - 6;
    const int h = 46 - 6;
    const int gx = x0 + (int(ui_gaze_x) * w) / 255;
    const int gy = y0 + (int(ui_gaze_y) * h) / 255;
    display.fillCircle(gx, gy, 2, SSD1306_WHITE);
  }
  // Eye open/closed indicators.
  auto draw_check = [&](int cx, int cy) {
    display.drawLine(cx - 5, cy, cx - 2, cy + 3, SSD1306_WHITE);
    display.drawLine(cx - 2, cy + 3, cx + 5, cy - 5, SSD1306_WHITE);
  };
  auto draw_cross = [&](int cx, int cy) {
    display.drawLine(cx - 4, cy - 4, cx + 4, cy + 4, SSD1306_WHITE);
    display.drawLine(cx + 4, cy - 4, cx - 4, cy + 4, SSD1306_WHITE);
  };
  if (ui_left_eye) draw_check(15, 32); else draw_cross(15, 32);
  if (ui_right_eye) draw_check(39, 32); else draw_cross(39, 32);
  display.drawCircle(15, 32, 8, SSD1306_WHITE);
  display.drawCircle(39, 32, 8, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(12, 16);
  display.print(F("L"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(36, 16);
  display.print(F("R"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(2, 44);
  display.print(F("Position:"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_text_el_269.length(); i++) {
      const char ch = ui_text_el_269[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    const int oy = max(0, (8 - (lines_n * line_h)) / 2);
    int cy = 53 + oy;
    size_t i = 0;
    while (i <= ui_text_el_269.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_text_el_269.length()) {
        const char ch = ui_text_el_269[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 2 + max(0, (51 - (cols * 6 * 1)) / 2);
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_text_el_269.length()) {
        const char ch = ui_text_el_269[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_text_el_269.length()) break;
      // Newline.
      if (ui_text_el_269[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
}

// Dispatcher: choose which screen to draw from your main loop.
inline void draw_screen(Adafruit_SSD1306 &display, UiScreen screen) {
  switch (screen) {
    case UiScreen::LOADING: draw_loading_screen(display); break;
    case UiScreen::BOOT: draw_boot_screen(display); break;
    case UiScreen::FIND_POSITION: draw_find_position_screen(display); break;
    case UiScreen::MOVE_CLOSER: draw_move_closer_screen(display); break;
    case UiScreen::MOVE_FARTHER: draw_move_farther_screen(display); break;
    case UiScreen::IN_POSITION: draw_in_position_screen(display); break;
    case UiScreen::CALIBRATION: draw_calibration_screen(display); break;
    case UiScreen::RECORD_CONFIRMATION: draw_record_confirmation_screen(display); break;
    case UiScreen::RECORDING: draw_recording_screen(display); break;
    case UiScreen::STOP_RECORD: draw_stop_record_screen(display); break;
    case UiScreen::INFERENCE_LOADING: draw_inference_loading_screen(display); break;
    case UiScreen::RESULTS: draw_results_screen(display); break;
    case UiScreen::MONITORING: draw_monitoring_screen(display); break;
    default: draw_loading_screen(display); break;
  }
}

// Optional: legacy index-based dispatcher (maps to UiScreen values).
inline void draw_screen(Adafruit_SSD1306 &display, uint8_t index) {
  draw_screen(display, static_cast<UiScreen>(index));
}
