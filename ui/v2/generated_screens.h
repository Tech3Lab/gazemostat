#pragma once

// Auto-generated by mercure_ui UI designer.
// Target: 128x64 SSD1306 using Adafruit_SSD1306 + Adafruit_GFX.
// NOTE: draw_*_screen() functions do NOT call display.display().
// Call display.display() once per frame after draw_screen(...).

#include <Arduino.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

static const uint8_t UI_DESIGNER_W = 128;
static const uint8_t UI_DESIGNER_H = 64;

// Available screens (auto-generated).
enum class UiScreen : uint8_t {
  BOOT = 0,
  LOADING = 1,
  IN_POSITION = 2,
  MOVE_CLOSER = 3,
  MOVE_FARTHER = 4,
  CALIBRATION = 5,
  CALIBRATION_WARNING = 6,
  RECORDING = 7,
  STOP_CONFIRMATION = 8,
  MISSING_STOP_EVENT = 9,
  INFERENCE_LOADING = 10,
  GLOBAL_RESULTS = 11,
  EVENT_RESULTS = 12,
  QUIT_CONFIRMATION = 13,
  MONITOR_GAZE = 14,
};

// Dynamic element variables (auto-generated).
// Update these values at runtime before calling draw_*_screen() / draw_screen().
static bool ui_tracker_detected = false;
static bool ui_led_detected = false;
static bool ui_connection = false;
static String ui_loading_data = "{Metadata}";
static String ui_calibration_status = "STATUS";
static String ui_text_el_112 = "Quality";
static String ui_recording_timer = "02:23";
static String ui_event_time = "00:24";
static String ui_event_name = "STOP EVENT 3";
static String ui_inference_timer = "02:34";
static String ui_event_result_title = "EVENT N RESULT";
static String ui_last_result_btn_txt = "Next>";

// Dynamic variables (auto-generated).
enum class UiDynamicVar : uint8_t {
  UI_TRACKER_DETECTED,
  UI_LED_DETECTED,
  UI_CONNECTION,
  UI_LOADING_DATA,
  UI_CALIBRATION_STATUS,
  UI_TEXT_EL_112,
  UI_RECORDING_TIMER,
  UI_EVENT_TIME,
  UI_EVENT_NAME,
  UI_INFERENCE_TIMER,
  UI_EVENT_RESULT_TITLE,
  UI_LAST_RESULT_BTN_TXT,
};

// Generic fallback: unknown types/vars return default and do nothing.
template <typename T> inline T ui_get(UiDynamicVar) { return T(); }
template <typename T> inline void ui_set(UiDynamicVar, const T &) {}

template <> inline bool ui_get<bool>(UiDynamicVar var) {
  switch (var) {
    case UiDynamicVar::UI_TRACKER_DETECTED: return ui_tracker_detected;
    case UiDynamicVar::UI_LED_DETECTED: return ui_led_detected;
    case UiDynamicVar::UI_CONNECTION: return ui_connection;
    default: return false;
  }
}
template <> inline void ui_set<bool>(UiDynamicVar var, const bool &value) {
  switch (var) {
    case UiDynamicVar::UI_TRACKER_DETECTED: ui_tracker_detected = value; break;
    case UiDynamicVar::UI_LED_DETECTED: ui_led_detected = value; break;
    case UiDynamicVar::UI_CONNECTION: ui_connection = value; break;
    default: break;
  }
}

template <> inline String ui_get<String>(UiDynamicVar var) {
  switch (var) {
    case UiDynamicVar::UI_LOADING_DATA: return ui_loading_data;
    case UiDynamicVar::UI_CALIBRATION_STATUS: return ui_calibration_status;
    case UiDynamicVar::UI_TEXT_EL_112: return ui_text_el_112;
    case UiDynamicVar::UI_RECORDING_TIMER: return ui_recording_timer;
    case UiDynamicVar::UI_EVENT_TIME: return ui_event_time;
    case UiDynamicVar::UI_EVENT_NAME: return ui_event_name;
    case UiDynamicVar::UI_INFERENCE_TIMER: return ui_inference_timer;
    case UiDynamicVar::UI_EVENT_RESULT_TITLE: return ui_event_result_title;
    case UiDynamicVar::UI_LAST_RESULT_BTN_TXT: return ui_last_result_btn_txt;
    default: return String("");
  }
}
template <> inline void ui_set<String>(UiDynamicVar var, const String &value) {
  switch (var) {
    case UiDynamicVar::UI_LOADING_DATA: ui_loading_data = value; break;
    case UiDynamicVar::UI_CALIBRATION_STATUS: ui_calibration_status = value; break;
    case UiDynamicVar::UI_TEXT_EL_112: ui_text_el_112 = value; break;
    case UiDynamicVar::UI_RECORDING_TIMER: ui_recording_timer = value; break;
    case UiDynamicVar::UI_EVENT_TIME: ui_event_time = value; break;
    case UiDynamicVar::UI_EVENT_NAME: ui_event_name = value; break;
    case UiDynamicVar::UI_INFERENCE_TIMER: ui_inference_timer = value; break;
    case UiDynamicVar::UI_EVENT_RESULT_TITLE: ui_event_result_title = value; break;
    case UiDynamicVar::UI_LAST_RESULT_BTN_TXT: ui_last_result_btn_txt = value; break;
    default: break;
  }
}

// Screen 0: boot
inline void draw_boot_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.drawRect(8, 21, 8, 8, SSD1306_WHITE);
  if (ui_tracker_detected) {
    display.drawLine(10, 25, 10, 26, SSD1306_WHITE);
    display.drawLine(10, 26, 13, 23, SSD1306_WHITE);
  }
  display.drawRect(8, 31, 8, 8, SSD1306_WHITE);
  if (ui_led_detected) {
    display.drawLine(10, 35, 10, 36, SSD1306_WHITE);
    display.drawLine(10, 36, 13, 33, SSD1306_WHITE);
  }
  display.drawRect(8, 41, 8, 8, SSD1306_WHITE);
  if (ui_connection) {
    display.drawLine(10, 45, 10, 46, SSD1306_WHITE);
    display.drawLine(10, 46, 13, 43, SSD1306_WHITE);
  }
  // PLACEHOLDER region: x=19, y=53, w=10, h=10
  // TODO: add custom drawing code here
  // Example: display.drawBitmap(...);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(19, 21);
  display.print(F("Eye tracker"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(19, 31);
  display.print(F("LED"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(19, 41);
  display.print(F("Connection"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(40, 1);
  display.print(F("LOADING,"));
  display.setCursor(22, 9);
  display.print(F("PLEASE WAIT..."));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_loading_data.length(); i++) {
      const char ch = ui_loading_data[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 54;
    size_t i = 0;
    while (i <= ui_loading_data.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_loading_data.length()) {
        const char ch = ui_loading_data[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 32;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_loading_data.length()) {
        const char ch = ui_loading_data[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_loading_data.length()) break;
      // Newline.
      if (ui_loading_data[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
}

// Screen 1: loading
inline void draw_loading_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  // PLACEHOLDER region: x=52, y=23, w=24, h=23
  // TODO: add custom drawing code here
  // Example: display.drawBitmap(...);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_loading_data.length(); i++) {
      const char ch = ui_loading_data[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 51;
    size_t i = 0;
    while (i <= ui_loading_data.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_loading_data.length()) {
        const char ch = ui_loading_data[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 34;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_loading_data.length()) {
        const char ch = ui_loading_data[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_loading_data.length()) break;
      // Newline.
      if (ui_loading_data[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(42, 3);
  display.print(F("LOADING,"));
  display.setCursor(24, 11);
  display.print(F("PLEASE WAIT..."));
}

// Screen 2: in_position
inline void draw_in_position_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.drawLine(0, 11, 127, 11, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(3, 2);
  display.print(F("HEAD POSITION"));
  display.drawRoundRect(7, 17, 41, 16, 3, SSD1306_WHITE);
  {
    const int x1 = 7, y1 = 36, x2 = 49, y2 = 37;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  {
    const int x1 = 6, y1 = 59, x2 = 12, y2 = 35;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  {
    const int x1 = 43, y1 = 35, x2 = 49, y2 = 59;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  {
    const int x1 = 3, y1 = 58, x2 = 54, y2 = 59;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  display.drawCircle(28, 48, 8, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(63, 32);
  display.print(F("YOU'RE IN"));
  display.setCursor(66, 40);
  display.print(F("POSITION"));
  display.drawCircle(89, 23, 6, SSD1306_WHITE);
  display.drawLine(86, 23, 88, 25, SSD1306_WHITE);
  display.drawLine(88, 25, 92, 21, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(84, 55);
  display.print(F("Calib.>"));
}

// Screen 3: move_closer
inline void draw_move_closer_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.drawLine(0, 11, 127, 11, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(3, 2);
  display.print(F("HEAD POSITION"));
  display.drawRoundRect(7, 17, 41, 16, 3, SSD1306_WHITE);
  {
    const int x1 = 7, y1 = 36, x2 = 49, y2 = 37;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  {
    const int x1 = 6, y1 = 59, x2 = 12, y2 = 35;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  {
    const int x1 = 43, y1 = 35, x2 = 49, y2 = 59;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  {
    const int x1 = 3, y1 = 58, x2 = 54, y2 = 59;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  display.drawCircle(28, 54, 8, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(72, 36);
  display.print(F("PLEASE"));
  display.setCursor(57, 44);
  display.print(F("MOVE CLOSER"));
  display.drawTriangle(90, 22, 84, 32, 95, 32, SSD1306_WHITE);
  display.drawLine(90, 25, 90, 28, SSD1306_WHITE);
  display.fillRect(89, 30, 2, 2, SSD1306_WHITE);
}

// Screen 4: move_farther
inline void draw_move_farther_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.drawLine(0, 11, 127, 11, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(3, 2);
  display.print(F("HEAD POSITION"));
  display.drawRoundRect(7, 17, 41, 16, 3, SSD1306_WHITE);
  {
    const int x1 = 7, y1 = 36, x2 = 49, y2 = 37;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  {
    const int x1 = 6, y1 = 59, x2 = 12, y2 = 35;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  {
    const int x1 = 43, y1 = 35, x2 = 49, y2 = 59;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  {
    const int x1 = 3, y1 = 58, x2 = 54, y2 = 59;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  display.drawCircle(28, 41, 8, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(73, 36);
  display.print(F("PLEASE"));
  display.setCursor(55, 44);
  display.print(F("MOVE FARTHER"));
  display.drawTriangle(90, 22, 84, 32, 95, 32, SSD1306_WHITE);
  display.drawLine(90, 25, 90, 28, SSD1306_WHITE);
  display.fillRect(89, 30, 2, 2, SSD1306_WHITE);
}

// Screen 5: calibration
inline void draw_calibration_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.drawLine(0, 11, 127, 11, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(3, 2);
  display.print(F("CALIBRATION"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(84, 55);
  display.print(F("Record>"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(2, 55);
  display.print(F("<Back"));
  // PLACEHOLDER region: x=66, y=19, w=10, h=10
  // TODO: add custom drawing code here
  // Example: display.drawBitmap(...);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_calibration_status.length(); i++) {
      const char ch = ui_calibration_status[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 20;
    size_t i = 0;
    while (i <= ui_calibration_status.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_calibration_status.length()) {
        const char ch = ui_calibration_status[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 80;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_calibration_status.length()) {
        const char ch = ui_calibration_status[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_calibration_status.length()) break;
      // Newline.
      if (ui_calibration_status[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_text_el_112.length(); i++) {
      const char ch = ui_text_el_112[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    const int oy = max(0, (8 - (lines_n * line_h)) / 2);
    int cy = 38 + oy;
    size_t i = 0;
    while (i <= ui_text_el_112.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_text_el_112.length()) {
        const char ch = ui_text_el_112[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 68 + max(0, (48 - (cols * 6 * 1)) / 2);
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_text_el_112.length()) {
        const char ch = ui_text_el_112[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_text_el_112.length()) break;
      // Newline.
      if (ui_text_el_112[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.drawCircle(15, 37, 8, SSD1306_WHITE);
  display.drawCircle(40, 37, 8, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(12, 18);
  display.print(F("L"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(37, 18);
  display.print(F("R"));
  display.drawLine(10, 32, 19, 41, SSD1306_WHITE);
  display.drawLine(19, 32, 10, 41, SSD1306_WHITE);
  display.drawLine(35, 37, 38, 41, SSD1306_WHITE);
  display.drawLine(38, 41, 44, 33, SSD1306_WHITE);
}

// Screen 6: calibration_warning
inline void draw_calibration_warning_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.drawTriangle(33, 5, 28, 14, 38, 14, SSD1306_WHITE);
  display.drawLine(33, 7, 33, 11, SSD1306_WHITE);
  display.fillRect(32, 12, 2, 2, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(43, 7);
  display.print(F("WARNING"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(32, 24);
  display.print(F("Record with"));
  display.setCursor(14, 32);
  display.print(F("poor calibration?"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(84, 55);
  display.print(F("Record>"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(2, 55);
  display.print(F("<Calib."));
}

// Screen 7: recording
inline void draw_recording_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.drawLine(0, 11, 127, 11, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(3, 2);
  display.print(F("RECORDING..."));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(96, 55);
  display.print(F("Stop>"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_recording_timer.length(); i++) {
      const char ch = ui_recording_timer[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 19;
    size_t i = 0;
    while (i <= ui_recording_timer.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_recording_timer.length()) {
        const char ch = ui_recording_timer[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 89;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_recording_timer.length()) {
        const char ch = ui_recording_timer[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_recording_timer.length()) break;
      // Newline.
      if (ui_recording_timer[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(9, 19);
  display.print(F("TOTAL TIME:"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(9, 29);
  display.print(F("EVENT TIME:"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_event_time.length(); i++) {
      const char ch = ui_event_time[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 29;
    size_t i = 0;
    while (i <= ui_event_time.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_event_time.length()) {
        const char ch = ui_event_time[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 89;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_event_time.length()) {
        const char ch = ui_event_time[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_event_time.length()) break;
      // Newline.
      if (ui_event_time[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.fillRect(25, 43, 77, 8, SSD1306_WHITE);
  display.setTextColor(SSD1306_BLACK);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_event_name.length(); i++) {
      const char ch = ui_event_name[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    const int oy = max(0, (8 - (lines_n * line_h)) / 2);
    int cy = 43 + oy;
    size_t i = 0;
    while (i <= ui_event_name.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_event_name.length()) {
        const char ch = ui_event_name[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 25 + max(0, (77 - (cols * 6 * 1)) / 2);
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_event_name.length()) {
        const char ch = ui_event_name[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_event_name.length()) break;
      // Newline.
      if (ui_event_name[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
}

// Screen 8: stop_confirmation
inline void draw_stop_confirmation_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(78, 55);
  display.print(F("Confirm>"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(22, 27);
  display.print(F("End recording?"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(2, 55);
  display.print(F("<Back rec."));
  display.drawLine(0, 11, 127, 11, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(3, 2);
  display.print(F("RECORDING..."));
}

// Screen 9: missing_stop_event
inline void draw_missing_stop_event_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(78, 55);
  display.print(F("Confirm>"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.fillRect(12, 15, 104, 18, SSD1306_WHITE);
  display.setTextColor(SSD1306_BLACK);
  display.setCursor(13, 16);
  display.print(F("LAST EVENT IS NOT"));
  display.setCursor(46, 24);
  display.print(F("CLOSED"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(2, 55);
  display.print(F("<Back rec."));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(43, 4);
  display.print(F("WARNING"));
  display.drawTriangle(33, 2, 28, 11, 38, 11, SSD1306_WHITE);
  display.drawLine(33, 4, 33, 8, SSD1306_WHITE);
  display.fillRect(32, 9, 2, 2, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(25, 35);
  display.print(F("End recording"));
  display.setCursor(43, 43);
  display.print(F("anyway?"));
}

// Screen 10: inference_loading
inline void draw_inference_loading_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(34, 3);
  display.print(F("ANALYSING,"));
  display.setCursor(22, 11);
  display.print(F("PLEASE WAIT..."));
  display.drawRect(10, 28, 109, 5, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_loading_data.length(); i++) {
      const char ch = ui_loading_data[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 53;
    size_t i = 0;
    while (i <= ui_loading_data.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_loading_data.length()) {
        const char ch = ui_loading_data[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 34;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_loading_data.length()) {
        const char ch = ui_loading_data[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_loading_data.length()) break;
      // Newline.
      if (ui_loading_data[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_inference_timer.length(); i++) {
      const char ch = ui_inference_timer[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 34;
    size_t i = 0;
    while (i <= ui_inference_timer.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_inference_timer.length()) {
        const char ch = ui_inference_timer[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 90;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_inference_timer.length()) {
        const char ch = ui_inference_timer[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_inference_timer.length()) break;
      // Newline.
      if (ui_inference_timer[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
}

// Screen 11: global_results
inline void draw_global_results_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.drawLine(0, 11, 127, 11, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(21, 2);
  display.print(F("GLOBAL RESULTS"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(96, 55);
  display.print(F("Next>"));
}

// Screen 12: event_results
inline void draw_event_results_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.drawLine(0, 11, 127, 11, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_event_result_title.length(); i++) {
      const char ch = ui_event_result_title[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    const int oy = max(0, (9 - (lines_n * line_h)) / 2);
    int cy = 2 + oy;
    size_t i = 0;
    while (i <= ui_event_result_title.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_event_result_title.length()) {
        const char ch = ui_event_result_title[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 21 + max(0, (85 - (cols * 6 * 1)) / 2);
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_event_result_title.length()) {
        const char ch = ui_event_result_title[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_event_result_title.length()) break;
      // Newline.
      if (ui_event_result_title[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(2, 55);
  display.print(F("<Back"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_last_result_btn_txt.length(); i++) {
      const char ch = ui_last_result_btn_txt[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 55;
    size_t i = 0;
    while (i <= ui_last_result_btn_txt.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_last_result_btn_txt.length()) {
        const char ch = ui_last_result_btn_txt[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 96;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_last_result_btn_txt.length()) {
        const char ch = ui_last_result_btn_txt[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_last_result_btn_txt.length()) break;
      // Newline.
      if (ui_last_result_btn_txt[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
}

// Screen 13: quit_confirmation
inline void draw_quit_confirmation_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(44, 4);
  display.print(F("WARNING"));
  display.drawTriangle(34, 2, 29, 11, 39, 11, SSD1306_WHITE);
  display.drawLine(34, 4, 34, 8, SSD1306_WHITE);
  display.fillRect(33, 9, 2, 2, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_last_result_btn_txt.length(); i++) {
      const char ch = ui_last_result_btn_txt[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 55;
    size_t i = 0;
    while (i <= ui_last_result_btn_txt.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_last_result_btn_txt.length()) {
        const char ch = ui_last_result_btn_txt[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 78;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_last_result_btn_txt.length()) {
        const char ch = ui_last_result_btn_txt[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_last_result_btn_txt.length()) break;
      // Newline.
      if (ui_last_result_btn_txt[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(2, 55);
  display.print(F("<Back"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(13, 22);
  display.print(F("All data will be"));
  display.setCursor(8, 30);
  display.print(F("permanently erased"));
  display.setCursor(28, 38);
  display.print(F("from device"));
}

// Screen 14: monitor_gaze
inline void draw_monitor_gaze_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.drawLine(0, 11, 127, 11, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(30, 2);
  display.print(F("GAZE VIEWER"));
  display.drawRoundRect(57, 15, 69, 46, 3, SSD1306_WHITE);
  display.fillCircle(74, 44, 2, SSD1306_WHITE);
  display.drawLine(33, 41, 36, 45, SSD1306_WHITE);
  display.drawLine(36, 45, 42, 37, SSD1306_WHITE);
  display.drawLine(11, 36, 20, 45, SSD1306_WHITE);
  display.drawLine(20, 36, 11, 45, SSD1306_WHITE);
  display.drawCircle(16, 41, 8, SSD1306_WHITE);
  display.drawCircle(39, 41, 8, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(12, 21);
  display.print(F("L"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(36, 21);
  display.print(F("R"));
}

// Dispatcher: choose which screen to draw from your main loop.
inline void draw_screen(Adafruit_SSD1306 &display, UiScreen screen) {
  switch (screen) {
    case UiScreen::BOOT: draw_boot_screen(display); break;
    case UiScreen::LOADING: draw_loading_screen(display); break;
    case UiScreen::IN_POSITION: draw_in_position_screen(display); break;
    case UiScreen::MOVE_CLOSER: draw_move_closer_screen(display); break;
    case UiScreen::MOVE_FARTHER: draw_move_farther_screen(display); break;
    case UiScreen::CALIBRATION: draw_calibration_screen(display); break;
    case UiScreen::CALIBRATION_WARNING: draw_calibration_warning_screen(display); break;
    case UiScreen::RECORDING: draw_recording_screen(display); break;
    case UiScreen::STOP_CONFIRMATION: draw_stop_confirmation_screen(display); break;
    case UiScreen::MISSING_STOP_EVENT: draw_missing_stop_event_screen(display); break;
    case UiScreen::INFERENCE_LOADING: draw_inference_loading_screen(display); break;
    case UiScreen::GLOBAL_RESULTS: draw_global_results_screen(display); break;
    case UiScreen::EVENT_RESULTS: draw_event_results_screen(display); break;
    case UiScreen::QUIT_CONFIRMATION: draw_quit_confirmation_screen(display); break;
    case UiScreen::MONITOR_GAZE: draw_monitor_gaze_screen(display); break;
    default: draw_boot_screen(display); break;
  }
}

// Optional: legacy index-based dispatcher (maps to UiScreen values).
inline void draw_screen(Adafruit_SSD1306 &display, uint8_t index) {
  draw_screen(display, static_cast<UiScreen>(index));
}
