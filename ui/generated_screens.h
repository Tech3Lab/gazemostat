#pragma once

// Auto-generated by mercure_ui UI designer.
// Target: 128x64 SSD1306 using Adafruit_SSD1306 + Adafruit_GFX.

#include <Arduino.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

static const uint8_t UI_DESIGNER_W = 128;
static const uint8_t UI_DESIGNER_H = 64;

// Available screens (auto-generated).
enum class UiScreen : uint8_t {
  BOOT = 0,
  POSITION = 1,
  CALIBRATION = 2,
  RECORDING = 3,
  MONITOR_POS = 4,
  MONITOR_GAZE = 5,
  RESULTS = 6,
};

// Dynamic element variables (auto-generated).
// Update these values at runtime before calling draw_*_screen() / draw_screen().
static bool ui_tracker_detected = false;
static bool ui_led_detected = false;
static bool ui_connection = false;
static bool ui_calibration_ok = false;

// Dynamic variables (auto-generated).
enum class UiDynamicVar : uint8_t {
  UI_TRACKER_DETECTED,
  UI_LED_DETECTED,
  UI_CONNECTION,
  UI_CALIBRATION_OK,
};

// Generic fallback: unknown types/vars return default and do nothing.
template <typename T> inline T ui_get(UiDynamicVar) { return T(); }
template <typename T> inline void ui_set(UiDynamicVar, const T &) {}

template <> inline bool ui_get<bool>(UiDynamicVar var) {
  switch (var) {
    case UiDynamicVar::UI_TRACKER_DETECTED: return ui_tracker_detected;
    case UiDynamicVar::UI_LED_DETECTED: return ui_led_detected;
    case UiDynamicVar::UI_CONNECTION: return ui_connection;
    case UiDynamicVar::UI_CALIBRATION_OK: return ui_calibration_ok;
    default: return false;
  }
}
template <> inline void ui_set<bool>(UiDynamicVar var, const bool &value) {
  switch (var) {
    case UiDynamicVar::UI_TRACKER_DETECTED: ui_tracker_detected = value; break;
    case UiDynamicVar::UI_LED_DETECTED: ui_led_detected = value; break;
    case UiDynamicVar::UI_CONNECTION: ui_connection = value; break;
    case UiDynamicVar::UI_CALIBRATION_OK: ui_calibration_ok = value; break;
    default: break;
  }
}

template <> inline String ui_get<String>(UiDynamicVar var) {
  switch (var) {
    default: return String("");
  }
}
template <> inline void ui_set<String>(UiDynamicVar var, const String &value) {
  switch (var) {
    default: break;
  }
}

// Screen 0: boot
inline void draw_boot_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.setTextSize(2);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(8, 3);
  display.print(F("LOADING, PLEASE WAIT..."));
  display.drawRect(56, 16, 8, 8, SSD1306_WHITE);
  if (ui_tracker_detected) {
    display.drawLine(58, 20, 58, 21, SSD1306_WHITE);
    display.drawLine(58, 21, 61, 18, SSD1306_WHITE);
  }
  display.drawRect(56, 32, 8, 8, SSD1306_WHITE);
  if (ui_led_detected) {
    display.drawLine(58, 36, 58, 37, SSD1306_WHITE);
    display.drawLine(58, 37, 61, 34, SSD1306_WHITE);
  }
  display.drawRect(56, 48, 8, 8, SSD1306_WHITE);
  if (ui_connection) {
    display.drawLine(58, 52, 58, 53, SSD1306_WHITE);
    display.drawLine(58, 53, 61, 50, SSD1306_WHITE);
  }
  // PLACEHOLDER region: x=8, y=16, w=40, h=40
  // TODO: add custom drawing code here
  // Example: display.drawBitmap(...);
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(71, 16);
  display.print(F("Eye tracker detected"));
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(72, 32);
  display.print(F("LED detected"));
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(72, 48);
  display.print(F("Connection"));
  display.display();
}

// Screen 1: position
inline void draw_position_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.drawRect(40, 2, 48, 16, SSD1306_WHITE);
  {
    const int x1 = 79, y1 = 16, x2 = 88, y2 = 50;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  {
    const int x1 = 40, y1 = 48, x2 = 48, y2 = 16;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  {
    const int x1 = 33, y1 = 46, x2 = 95, y2 = 47;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  {
    const int x1 = 42, y1 = 21, x2 = 84, y2 = 22;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1306_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1306_WHITE);
      }
    }
  }
  display.drawCircle(64, 34, 11, SSD1306_WHITE);
  display.setTextSize(2);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(33, 54);
  display.print(F("START CALIBRATION"));
  display.drawRect(30, 52, 70, 10, SSD1306_WHITE);
  display.display();
}

// Screen 2: calibration
inline void draw_calibration_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.setTextSize(2);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(31, 3);
  display.print(F("CALIBRATION CHECK"));
  display.setTextSize(3);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(57, 24);
  display.print(F("READY"));
  display.setTextSize(2);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(32, 48);
  display.print(F("CALIBRATION CHECK"));
  display.drawRect(36, 22, 12, 12, SSD1306_WHITE);
  if (ui_calibration_ok) {
    display.drawLine(38, 28, 40, 31, SSD1306_WHITE);
    display.drawLine(40, 31, 45, 24, SSD1306_WHITE);
  }
  display.drawRect(30, 47, 70, 12, SSD1306_WHITE);
  display.display();
}

// Screen 3: recording
inline void draw_recording_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.setTextSize(2);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(8, 5);
  display.print(F("MARKER STATUS: "));
  display.setTextSize(4);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(12, 23);
  display.print(F("MARKERS :"));
  display.setTextSize(2);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(98, 6);
  display.print(F(" END"));
  display.setTextSize(2);
  display.fillRect(78, 6, 20, 6, SSD1306_WHITE);
  display.setTextColor(SSD1306_BLACK);
  display.setCursor(78, 6);
  display.print(F("START"));
  display.fillCircle(14, 52, 3, SSD1306_WHITE);
  display.setTextSize(2);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(19, 49);
  display.print(F("REC"));
  display.setTextSize(2);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(56, 48);
  display.print(F("STOP RECORDING"));
  display.drawRect(51, 46, 63, 12, SSD1306_WHITE);
  display.setTextSize(4);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(94, 23);
  display.print(F("03"));
  display.display();
}

// Screen 4: Monitor_pos
inline void draw_monitor_pos_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(28, 24);
  display.print(F("Monitoring pos"));
  display.display();
}

// Screen 5: Monitor_gaze
inline void draw_monitor_gaze_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(28, 24);
  display.print(F("Monitoring gaze"));
  display.display();
}

// Screen 6: results
inline void draw_results_screen(Adafruit_SSD1306 &display) {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(26, 20);
  display.print(F("Results"));
  display.display();
}

// Dispatcher: choose which screen to draw from your main loop.
inline void draw_screen(Adafruit_SSD1306 &display, UiScreen screen) {
  switch (screen) {
    case UiScreen::BOOT: draw_boot_screen(display); break;
    case UiScreen::POSITION: draw_position_screen(display); break;
    case UiScreen::CALIBRATION: draw_calibration_screen(display); break;
    case UiScreen::RECORDING: draw_recording_screen(display); break;
    case UiScreen::MONITOR_POS: draw_monitor_pos_screen(display); break;
    case UiScreen::MONITOR_GAZE: draw_monitor_gaze_screen(display); break;
    case UiScreen::RESULTS: draw_results_screen(display); break;
    default: draw_boot_screen(display); break;
  }
}

// Optional: legacy index-based dispatcher (maps to UiScreen values).
inline void draw_screen(Adafruit_SSD1306 &display, uint8_t index) {
  draw_screen(display, static_cast<UiScreen>(index));
}
