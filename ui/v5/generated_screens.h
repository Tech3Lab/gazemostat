#pragma once

// Auto-generated by mercure_ui SSD1327 UI designer.
// Target: 128x128 SSD1327 (4-bit grayscale) using Adafruit_SSD1327 + Adafruit_GFX.
// NOTE: draw_*_screen() functions do NOT call display.display().
// Call display.display() once per frame after draw_screen(...).

#include <Arduino.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1327.h>

// Fallback color definitions for 4-bit grayscale displays.
#ifndef SSD1327_BLACK
#define SSD1327_BLACK 0x0
#endif
#ifndef SSD1327_WHITE
#define SSD1327_WHITE 0xF
#endif

static const uint8_t UI_DESIGNER_W = 128;
static const uint8_t UI_DESIGNER_H = 128;

// Available screens (auto-generated).
enum class UiScreen : uint8_t {
  LOADING = 0,
  BOOT = 1,
  FIND_POSITION = 2,
  MOVE_CLOSER = 3,
  MOVE_FARTHER = 4,
  IN_POSITION = 5,
  CALIBRATION = 6,
  RECORD_CONFIRMATION = 7,
  RECORDING = 8,
  STOP_RECORD = 9,
  INFERENCE_LOADING = 10,
  RESULTS = 11,
  MONITORING = 12,
};

// Dynamic type for gaze path coordinates.
struct UiGazePoint {
  int16_t x;
  int16_t y;
};

// Dynamic element variables (auto-generated).
// Update these values at runtime before calling draw_*_screen() / draw_screen().
static String ui_loading_data = "{Metadata}";
static bool ui_tracker_detected = false;
static bool ui_led_detected = true;
static bool ui_connection = true;
static bool ui_position_head = true;
static String ui_calib_start_btn = "Calibration>";
static bool ui_led_up_left = true;
static bool ui_led_up_right = true;
static bool ui_led_bottom_right = true;
static bool ui_led_bottom_left = true;
static String ui_calib_next_btn = "";
static String ui_calib_redo_btn = "";
static String ui_calib_result = "";
static String ui_recording_timer = "02:23";
static String ui_event_time = "00:24";
static String ui_event_name = "STOP EVENT 3";
static String ui_close_event_warning = "Event marker 29 will\nbe closed\nautomatically";
static String ui_inference_timer = "02:34";
static int16_t ui_inference_prog_bar = 50;
static String ui_results_title = "GLOBAL RESULTS";
static String ui_results_next_btn = "Next>";
static String ui_result_1 = "TEXT";
static String ui_result_2 = "TEXT";
static String ui_result_3 = "TEXT";
static String ui_result_4 = "TEXT";
static String ui_results_prev_btn = "<Previous";
static bool ui_right_eye = true;
static bool ui_left_eye = true;
static String ui_text_el_269 = "Good";
static UiGazePoint ui_gaze_point = {23, 11};

// Helper for dynamic text: interpret literal \n / \r sequences as newlines.
// This is useful when values come from JSON/serial protocols that escape newlines.
static inline String ui_normalize_dynamic_text(const String &s) {
  if (s.indexOf('\\') < 0) return s;
  String out;
  out.reserve(s.length());
  for (size_t i = 0; i < s.length(); i++) {
    const char ch = s[i];
    if (ch == '\\' && (i + 1) < s.length()) {
      const char n = s[i + 1];
      if (n == 'n') { out += '\n'; i++; continue; }
      if (n == 'r') { out += '\r'; i++; continue; }
    }
    out += ch;
  }
  return out;
}

// Dynamic variables (auto-generated).
enum class UiDynamicVar : uint8_t {
  UI_LOADING_DATA,
  UI_TRACKER_DETECTED,
  UI_LED_DETECTED,
  UI_CONNECTION,
  UI_POSITION_HEAD,
  UI_CALIB_START_BTN,
  UI_LED_UP_LEFT,
  UI_LED_UP_RIGHT,
  UI_LED_BOTTOM_RIGHT,
  UI_LED_BOTTOM_LEFT,
  UI_CALIB_NEXT_BTN,
  UI_CALIB_REDO_BTN,
  UI_CALIB_RESULT,
  UI_RECORDING_TIMER,
  UI_EVENT_TIME,
  UI_EVENT_NAME,
  UI_CLOSE_EVENT_WARNING,
  UI_INFERENCE_TIMER,
  UI_INFERENCE_PROG_BAR,
  UI_RESULTS_TITLE,
  UI_RESULTS_NEXT_BTN,
  UI_RESULT_1,
  UI_RESULT_2,
  UI_RESULT_3,
  UI_RESULT_4,
  UI_RESULTS_PREV_BTN,
  UI_RIGHT_EYE,
  UI_LEFT_EYE,
  UI_TEXT_EL_269,
  UI_GAZE_POINT,
};

// Generic fallback: unknown types/vars return default and do nothing.
template <typename T> inline T ui_get(UiDynamicVar) { return T(); }
template <typename T> inline void ui_set(UiDynamicVar, const T &) {}

template <> inline bool ui_get<bool>(UiDynamicVar var) {
  switch (var) {
    case UiDynamicVar::UI_TRACKER_DETECTED: return ui_tracker_detected;
    case UiDynamicVar::UI_LED_DETECTED: return ui_led_detected;
    case UiDynamicVar::UI_CONNECTION: return ui_connection;
    case UiDynamicVar::UI_POSITION_HEAD: return ui_position_head;
    case UiDynamicVar::UI_LED_UP_LEFT: return ui_led_up_left;
    case UiDynamicVar::UI_LED_UP_RIGHT: return ui_led_up_right;
    case UiDynamicVar::UI_LED_BOTTOM_RIGHT: return ui_led_bottom_right;
    case UiDynamicVar::UI_LED_BOTTOM_LEFT: return ui_led_bottom_left;
    case UiDynamicVar::UI_RIGHT_EYE: return ui_right_eye;
    case UiDynamicVar::UI_LEFT_EYE: return ui_left_eye;
    default: return false;
  }
}
template <> inline void ui_set<bool>(UiDynamicVar var, const bool &value) {
  switch (var) {
    case UiDynamicVar::UI_TRACKER_DETECTED: ui_tracker_detected = value; break;
    case UiDynamicVar::UI_LED_DETECTED: ui_led_detected = value; break;
    case UiDynamicVar::UI_CONNECTION: ui_connection = value; break;
    case UiDynamicVar::UI_POSITION_HEAD: ui_position_head = value; break;
    case UiDynamicVar::UI_LED_UP_LEFT: ui_led_up_left = value; break;
    case UiDynamicVar::UI_LED_UP_RIGHT: ui_led_up_right = value; break;
    case UiDynamicVar::UI_LED_BOTTOM_RIGHT: ui_led_bottom_right = value; break;
    case UiDynamicVar::UI_LED_BOTTOM_LEFT: ui_led_bottom_left = value; break;
    case UiDynamicVar::UI_RIGHT_EYE: ui_right_eye = value; break;
    case UiDynamicVar::UI_LEFT_EYE: ui_left_eye = value; break;
    default: break;
  }
}

template <> inline int16_t ui_get<int16_t>(UiDynamicVar var) {
  switch (var) {
    case UiDynamicVar::UI_INFERENCE_PROG_BAR: return ui_inference_prog_bar;
    default: return 0;
  }
}
template <> inline void ui_set<int16_t>(UiDynamicVar var, const int16_t &value) {
  switch (var) {
    case UiDynamicVar::UI_INFERENCE_PROG_BAR: ui_inference_prog_bar = value; break;
    default: break;
  }
}

template <> inline UiGazePoint ui_get<UiGazePoint>(UiDynamicVar var) {
  switch (var) {
    case UiDynamicVar::UI_GAZE_POINT: return ui_gaze_point;
    default: return UiGazePoint{0, 0};
  }
}
template <> inline void ui_set<UiGazePoint>(UiDynamicVar var, const UiGazePoint &value) {
  switch (var) {
    case UiDynamicVar::UI_GAZE_POINT: ui_gaze_point = value; break;
    default: break;
  }
}

template <> inline String ui_get<String>(UiDynamicVar var) {
  switch (var) {
    case UiDynamicVar::UI_LOADING_DATA: return ui_loading_data;
    case UiDynamicVar::UI_CALIB_START_BTN: return ui_calib_start_btn;
    case UiDynamicVar::UI_CALIB_NEXT_BTN: return ui_calib_next_btn;
    case UiDynamicVar::UI_CALIB_REDO_BTN: return ui_calib_redo_btn;
    case UiDynamicVar::UI_CALIB_RESULT: return ui_calib_result;
    case UiDynamicVar::UI_RECORDING_TIMER: return ui_recording_timer;
    case UiDynamicVar::UI_EVENT_TIME: return ui_event_time;
    case UiDynamicVar::UI_EVENT_NAME: return ui_event_name;
    case UiDynamicVar::UI_CLOSE_EVENT_WARNING: return ui_close_event_warning;
    case UiDynamicVar::UI_INFERENCE_TIMER: return ui_inference_timer;
    case UiDynamicVar::UI_RESULTS_TITLE: return ui_results_title;
    case UiDynamicVar::UI_RESULTS_NEXT_BTN: return ui_results_next_btn;
    case UiDynamicVar::UI_RESULT_1: return ui_result_1;
    case UiDynamicVar::UI_RESULT_2: return ui_result_2;
    case UiDynamicVar::UI_RESULT_3: return ui_result_3;
    case UiDynamicVar::UI_RESULT_4: return ui_result_4;
    case UiDynamicVar::UI_RESULTS_PREV_BTN: return ui_results_prev_btn;
    case UiDynamicVar::UI_TEXT_EL_269: return ui_text_el_269;
    default: return String("");
  }
}
template <> inline void ui_set<String>(UiDynamicVar var, const String &value) {
  switch (var) {
    case UiDynamicVar::UI_LOADING_DATA: ui_loading_data = ui_normalize_dynamic_text(value); break;
    case UiDynamicVar::UI_CALIB_START_BTN: ui_calib_start_btn = ui_normalize_dynamic_text(value); break;
    case UiDynamicVar::UI_CALIB_NEXT_BTN: ui_calib_next_btn = ui_normalize_dynamic_text(value); break;
    case UiDynamicVar::UI_CALIB_REDO_BTN: ui_calib_redo_btn = ui_normalize_dynamic_text(value); break;
    case UiDynamicVar::UI_CALIB_RESULT: ui_calib_result = ui_normalize_dynamic_text(value); break;
    case UiDynamicVar::UI_RECORDING_TIMER: ui_recording_timer = ui_normalize_dynamic_text(value); break;
    case UiDynamicVar::UI_EVENT_TIME: ui_event_time = ui_normalize_dynamic_text(value); break;
    case UiDynamicVar::UI_EVENT_NAME: ui_event_name = ui_normalize_dynamic_text(value); break;
    case UiDynamicVar::UI_CLOSE_EVENT_WARNING: ui_close_event_warning = ui_normalize_dynamic_text(value); break;
    case UiDynamicVar::UI_INFERENCE_TIMER: ui_inference_timer = ui_normalize_dynamic_text(value); break;
    case UiDynamicVar::UI_RESULTS_TITLE: ui_results_title = ui_normalize_dynamic_text(value); break;
    case UiDynamicVar::UI_RESULTS_NEXT_BTN: ui_results_next_btn = ui_normalize_dynamic_text(value); break;
    case UiDynamicVar::UI_RESULT_1: ui_result_1 = ui_normalize_dynamic_text(value); break;
    case UiDynamicVar::UI_RESULT_2: ui_result_2 = ui_normalize_dynamic_text(value); break;
    case UiDynamicVar::UI_RESULT_3: ui_result_3 = ui_normalize_dynamic_text(value); break;
    case UiDynamicVar::UI_RESULT_4: ui_result_4 = ui_normalize_dynamic_text(value); break;
    case UiDynamicVar::UI_RESULTS_PREV_BTN: ui_results_prev_btn = ui_normalize_dynamic_text(value); break;
    case UiDynamicVar::UI_TEXT_EL_269: ui_text_el_269 = ui_normalize_dynamic_text(value); break;
    default: break;
  }
}

// Convenience overload so callers can pass string literals / const char*.
inline void ui_set(UiDynamicVar var, const char *value) {
  ui_set<String>(var, String(value ? value : ""));
}

// Convenience overload for Arduino's F("...") (PROGMEM) strings.
inline void ui_set(UiDynamicVar var, const __FlashStringHelper *value) {
  ui_set<String>(var, String(value));
}

// Screen 0: loading
inline void draw_loading_screen(Adafruit_SSD1327 &display) {
  display.clearDisplay();
  // PLACEHOLDER region: x=52, y=52, w=24, h=23
  // TODO: add custom drawing code here
  // Example: display.drawBitmap(...);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_loading_data.length(); i++) {
      const char ch = ui_loading_data[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 114;
    size_t i = 0;
    while (i <= ui_loading_data.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_loading_data.length()) {
        const char ch = ui_loading_data[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 34;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_loading_data.length()) {
        const char ch = ui_loading_data[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_loading_data.length()) break;
      // Newline.
      if (ui_loading_data[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(40, 15);
  display.print(F("LOADING,"));
  display.setCursor(22, 23);
  display.print(F("PLEASE WAIT..."));
}

// Screen 1: boot
inline void draw_boot_screen(Adafruit_SSD1327 &display) {
  display.clearDisplay();
  display.drawRect(8, 40, 8, 8, SSD1327_WHITE);
  if (ui_tracker_detected) {
    display.drawLine(10, 44, 10, 45, SSD1327_WHITE);
    display.drawLine(10, 45, 13, 42, SSD1327_WHITE);
  }
  display.drawRect(8, 56, 8, 8, SSD1327_WHITE);
  if (ui_led_detected) {
    display.drawLine(10, 60, 10, 61, SSD1327_WHITE);
    display.drawLine(10, 61, 13, 58, SSD1327_WHITE);
  }
  display.drawRect(8, 72, 8, 8, SSD1327_WHITE);
  if (ui_connection) {
    display.drawLine(10, 76, 10, 77, SSD1327_WHITE);
    display.drawLine(10, 77, 13, 74, SSD1327_WHITE);
  }
  // PLACEHOLDER region: x=28, y=95, w=10, h=10
  // TODO: add custom drawing code here
  // Example: display.drawBitmap(...);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(21, 40);
  display.print(F("Tracker detected"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(21, 57);
  display.print(F("LED present"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(21, 73);
  display.print(F("Connection"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(43, 12);
  display.print(F("LOADING"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_loading_data.length(); i++) {
      const char ch = ui_loading_data[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 96;
    size_t i = 0;
    while (i <= ui_loading_data.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_loading_data.length()) {
        const char ch = ui_loading_data[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 40;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_loading_data.length()) {
        const char ch = ui_loading_data[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_loading_data.length()) break;
      // Newline.
      if (ui_loading_data[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(91, 119);
  display.print(F("Start>"));
}

// Screen 2: find_position
inline void draw_find_position_screen(Adafruit_SSD1327 &display) {
  display.clearDisplay();
  display.drawLine(0, 15, 127, 15, SSD1327_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(3, 4);
  display.print(F("POSITION SUBJECT"));
  display.drawRoundRect(37, 31, 54, 25, 3, SSD1327_WHITE);
  {
    const int x1 = 36, y1 = 63, x2 = 91, y2 = 64;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1327_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1327_WHITE);
      }
    }
  }
  {
    const int x1 = 30, y1 = 104, x2 = 41, y2 = 60;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1327_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1327_WHITE);
      }
    }
  }
  {
    const int x1 = 27, y1 = 101, x2 = 100, y2 = 101;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1327_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1327_WHITE);
      }
    }
  }
  if (ui_position_head) {
    display.drawCircle(64, 83, 13, SSD1327_WHITE);
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(90, 117);
  display.print(F("Start>"));
  {
    const int x1 = 86, y1 = 60, x2 = 97, y2 = 104;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1327_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1327_WHITE);
      }
    }
  }
}

// Screen 3: move_closer
inline void draw_move_closer_screen(Adafruit_SSD1327 &display) {
  display.clearDisplay();
  display.drawLine(0, 15, 127, 15, SSD1327_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(3, 4);
  display.print(F("POSITION SUBJECT"));
  display.drawRoundRect(37, 23, 54, 25, 3, SSD1327_WHITE);
  {
    const int x1 = 36, y1 = 54, x2 = 91, y2 = 55;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1327_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1327_WHITE);
      }
    }
  }
  {
    const int x1 = 30, y1 = 92, x2 = 41, y2 = 50;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1327_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1327_WHITE);
      }
    }
  }
  {
    const int x1 = 27, y1 = 90, x2 = 100, y2 = 90;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1327_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1327_WHITE);
      }
    }
  }
  if (ui_position_head) {
    display.drawCircle(64, 82, 13, SSD1327_WHITE);
  }
  {
    const int x1 = 87, y1 = 52, x2 = 98, y2 = 94;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1327_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1327_WHITE);
      }
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(46, 102);
  display.print(F("PLEASE"));
  display.setCursor(31, 110);
  display.print(F("MOVE CLOSER"));
  display.drawTriangle(16, 26, 7, 42, 25, 42, SSD1327_WHITE);
  display.drawLine(16, 30, 16, 36, SSD1327_WHITE);
  display.fillRect(15, 39, 2, 2, SSD1327_WHITE);
}

// Screen 4: move_farther
inline void draw_move_farther_screen(Adafruit_SSD1327 &display) {
  display.clearDisplay();
  display.drawLine(0, 15, 127, 15, SSD1327_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(3, 4);
  display.print(F("POSITION SUBJECT"));
  display.drawRoundRect(37, 23, 54, 25, 3, SSD1327_WHITE);
  {
    const int x1 = 36, y1 = 54, x2 = 91, y2 = 55;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1327_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1327_WHITE);
      }
    }
  }
  {
    const int x1 = 30, y1 = 92, x2 = 41, y2 = 50;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1327_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1327_WHITE);
      }
    }
  }
  {
    const int x1 = 27, y1 = 90, x2 = 100, y2 = 90;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1327_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1327_WHITE);
      }
    }
  }
  if (ui_position_head) {
    display.drawCircle(64, 63, 13, SSD1327_WHITE);
  }
  {
    const int x1 = 87, y1 = 52, x2 = 98, y2 = 94;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1327_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1327_WHITE);
      }
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(46, 102);
  display.print(F("PLEASE"));
  display.setCursor(28, 110);
  display.print(F("MOVE FARTHER"));
  display.drawTriangle(16, 26, 7, 42, 25, 42, SSD1327_WHITE);
  display.drawLine(16, 30, 16, 36, SSD1327_WHITE);
  display.fillRect(15, 39, 2, 2, SSD1327_WHITE);
}

// Screen 5: in_position
inline void draw_in_position_screen(Adafruit_SSD1327 &display) {
  display.clearDisplay();
  display.drawLine(0, 15, 127, 15, SSD1327_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(3, 4);
  display.print(F("POSITION SUBJECT"));
  display.drawRoundRect(37, 23, 54, 25, 3, SSD1327_WHITE);
  {
    const int x1 = 36, y1 = 54, x2 = 91, y2 = 55;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1327_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1327_WHITE);
      }
    }
  }
  {
    const int x1 = 30, y1 = 92, x2 = 41, y2 = 50;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1327_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1327_WHITE);
      }
    }
  }
  {
    const int x1 = 27, y1 = 90, x2 = 100, y2 = 90;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1327_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1327_WHITE);
      }
    }
  }
  if (ui_position_head) {
    display.drawCircle(64, 73, 13, SSD1327_WHITE);
  }
  {
    const int x1 = 87, y1 = 52, x2 = 98, y2 = 94;
    const int dx = x2 - x1;
    const int dy = y2 - y1;
    const int n = max(abs(dx), abs(dy));
    if (n == 0) {
      display.drawPixel(x1, y1, SSD1327_WHITE);
    } else {
      for (int i = 0; i <= n; i++) {
        if (((i / 2) % 2) != 0) continue; // 2 on, 2 off
        const int px = x1 + (dx * i) / n;
        const int py = y1 + (dy * i) / n;
        display.drawPixel(px, py, SSD1327_WHITE);
      }
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(37, 97);
  display.print(F("YOU'RE IN"));
  display.setCursor(40, 105);
  display.print(F("POSITION"));
  display.drawCircle(16, 36, 8, SSD1327_WHITE);
  display.drawLine(12, 36, 15, 39, SSD1327_WHITE);
  display.drawLine(15, 39, 20, 33, SSD1327_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_calib_start_btn.length(); i++) {
      const char ch = ui_calib_start_btn[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 119;
    size_t i = 0;
    while (i <= ui_calib_start_btn.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_calib_start_btn.length()) {
        const char ch = ui_calib_start_btn[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 55;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_calib_start_btn.length()) {
        const char ch = ui_calib_start_btn[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_calib_start_btn.length()) break;
      // Newline.
      if (ui_calib_start_btn[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
}

// Screen 6: calibration
inline void draw_calibration_screen(Adafruit_SSD1327 &display) {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_calib_start_btn.length(); i++) {
      const char ch = ui_calib_start_btn[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 119;
    size_t i = 0;
    while (i <= ui_calib_start_btn.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_calib_start_btn.length()) {
        const char ch = ui_calib_start_btn[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 18;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_calib_start_btn.length()) {
        const char ch = ui_calib_start_btn[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_calib_start_btn.length()) break;
      // Newline.
      if (ui_calib_start_btn[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  if (ui_led_up_left) {
    display.drawCircle(7, 11, 5, SSD1327_WHITE);
  }
  if (ui_led_up_right) {
    display.drawCircle(119, 11, 5, SSD1327_WHITE);
  }
  if (ui_led_bottom_right) {
    display.drawCircle(120, 77, 5, SSD1327_WHITE);
  }
  if (ui_led_bottom_left) {
    display.drawCircle(8, 77, 5, SSD1327_WHITE);
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_calib_next_btn.length(); i++) {
      const char ch = ui_calib_next_btn[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 119;
    size_t i = 0;
    while (i <= ui_calib_next_btn.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_calib_next_btn.length()) {
        const char ch = ui_calib_next_btn[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 96;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_calib_next_btn.length()) {
        const char ch = ui_calib_next_btn[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_calib_next_btn.length()) break;
      // Newline.
      if (ui_calib_next_btn[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_calib_redo_btn.length(); i++) {
      const char ch = ui_calib_redo_btn[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 119;
    size_t i = 0;
    while (i <= ui_calib_redo_btn.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_calib_redo_btn.length()) {
        const char ch = ui_calib_redo_btn[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 2;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_calib_redo_btn.length()) {
        const char ch = ui_calib_redo_btn[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_calib_redo_btn.length()) break;
      // Newline.
      if (ui_calib_redo_btn[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(2);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  {
    const int line_h = 8 * 2;
    int lines_n = 1;
    for (size_t i = 0; i < ui_calib_result.length(); i++) {
      const char ch = ui_calib_result[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    const int oy = max(0, (21 - (lines_n * line_h)) / 2);
    int cy = 30 + oy;
    size_t i = 0;
    while (i <= ui_calib_result.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_calib_result.length()) {
        const char ch = ui_calib_result[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 25 + max(0, (77 - (cols * 6 * 2)) / 2);
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_calib_result.length()) {
        const char ch = ui_calib_result[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_calib_result.length()) break;
      // Newline.
      if (ui_calib_result[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
}

// Screen 7: record_confirmation
inline void draw_record_confirmation_screen(Adafruit_SSD1327 &display) {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(15, 59);
  display.print(F("READY TO RECORD?"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(91, 118);
  display.print(F("Start>"));
}

// Screen 8: recording
inline void draw_recording_screen(Adafruit_SSD1327 &display) {
  display.clearDisplay();
  display.drawLine(0, 15, 127, 15, SSD1327_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(3, 4);
  display.print(F("RECORDING..."));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(37, 118);
  display.print(F("Stop recording>"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_recording_timer.length(); i++) {
      const char ch = ui_recording_timer[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 47;
    size_t i = 0;
    while (i <= ui_recording_timer.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_recording_timer.length()) {
        const char ch = ui_recording_timer[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 89;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_recording_timer.length()) {
        const char ch = ui_recording_timer[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_recording_timer.length()) break;
      // Newline.
      if (ui_recording_timer[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(9, 47);
  display.print(F("TOTAL TIME:"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(9, 59);
  display.print(F("EVENT TIME:"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_event_time.length(); i++) {
      const char ch = ui_event_time[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 59;
    size_t i = 0;
    while (i <= ui_event_time.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_event_time.length()) {
        const char ch = ui_event_time[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 89;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_event_time.length()) {
        const char ch = ui_event_time[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_event_time.length()) break;
      // Newline.
      if (ui_event_time[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_event_name.length(); i++) {
      const char ch = ui_event_name[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 89;
    size_t i = 0;
    while (i <= ui_event_name.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_event_name.length()) {
        const char ch = ui_event_name[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 34;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_event_name.length()) {
        const char ch = ui_event_name[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_event_name.length()) break;
      // Newline.
      if (ui_event_name[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.drawCircle(21, 93, 6, SSD1327_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(19, 89);
  display.print(F("A"));
  display.drawRoundRect(9, 83, 109, 20, 3, SSD1327_WHITE);
}

// Screen 9: stop_record
inline void draw_stop_record_screen(Adafruit_SSD1327 &display) {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(102, 118);
  display.print(F("Yes>"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(22, 42);
  display.print(F("End recording?"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(2, 118);
  display.print(F("<No"));
  display.drawLine(0, 15, 127, 15, SSD1327_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(3, 4);
  display.print(F("RECORDING..."));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_close_event_warning.length(); i++) {
      const char ch = ui_close_event_warning[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    const int oy = max(0, (30 - (lines_n * line_h)) / 2);
    int cy = 68 + oy;
    size_t i = 0;
    while (i <= ui_close_event_warning.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_close_event_warning.length()) {
        const char ch = ui_close_event_warning[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 0 + max(0, (128 - (cols * 6 * 1)) / 2);
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_close_event_warning.length()) {
        const char ch = ui_close_event_warning[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_close_event_warning.length()) break;
      // Newline.
      if (ui_close_event_warning[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
}

// Screen 10: inference_loading
inline void draw_inference_loading_screen(Adafruit_SSD1327 &display) {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(34, 23);
  display.print(F("ANALYSING,"));
  display.setCursor(22, 31);
  display.print(F("PLEASE WAIT..."));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_loading_data.length(); i++) {
      const char ch = ui_loading_data[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    const int oy = max(0, (9 - (lines_n * line_h)) / 2);
    int cy = 103 + oy;
    size_t i = 0;
    while (i <= ui_loading_data.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_loading_data.length()) {
        const char ch = ui_loading_data[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 34 + max(0, (60 - (cols * 6 * 1)) / 2);
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_loading_data.length()) {
        const char ch = ui_loading_data[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_loading_data.length()) break;
      // Newline.
      if (ui_loading_data[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_inference_timer.length(); i++) {
      const char ch = ui_inference_timer[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 70;
    size_t i = 0;
    while (i <= ui_inference_timer.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_inference_timer.length()) {
        const char ch = ui_inference_timer[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 89;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_inference_timer.length()) {
        const char ch = ui_inference_timer[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_inference_timer.length()) break;
      // Newline.
      if (ui_inference_timer[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.drawRect(9, 54, 110, 8, SSD1327_WHITE);
  {
    const int ui_val = max(0, min(100, (int)ui_inference_prog_bar));
    const int fill_w = max(1, (108 * ui_val) / 100);
    display.fillRect(10, 55, min(108, fill_w), 6, SSD1327_WHITE);
  }
}

// Screen 11: results
inline void draw_results_screen(Adafruit_SSD1327 &display) {
  display.clearDisplay();
  display.drawLine(0, 15, 127, 15, SSD1327_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_results_title.length(); i++) {
      const char ch = ui_results_title[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    const int oy = max(0, (9 - (lines_n * line_h)) / 2);
    int cy = 3 + oy;
    size_t i = 0;
    while (i <= ui_results_title.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_results_title.length()) {
        const char ch = ui_results_title[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 3 + max(0, (85 - (cols * 6 * 1)) / 2);
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_results_title.length()) {
        const char ch = ui_results_title[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_results_title.length()) break;
      // Newline.
      if (ui_results_title[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_results_next_btn.length(); i++) {
      const char ch = ui_results_next_btn[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 118;
    size_t i = 0;
    while (i <= ui_results_next_btn.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_results_next_btn.length()) {
        const char ch = ui_results_next_btn[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 97;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_results_next_btn.length()) {
        const char ch = ui_results_next_btn[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_results_next_btn.length()) break;
      // Newline.
      if (ui_results_next_btn[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_result_1.length(); i++) {
      const char ch = ui_result_1[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 26;
    size_t i = 0;
    while (i <= ui_result_1.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_result_1.length()) {
        const char ch = ui_result_1[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 3;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_result_1.length()) {
        const char ch = ui_result_1[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_result_1.length()) break;
      // Newline.
      if (ui_result_1[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_result_2.length(); i++) {
      const char ch = ui_result_2[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 48;
    size_t i = 0;
    while (i <= ui_result_2.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_result_2.length()) {
        const char ch = ui_result_2[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 3;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_result_2.length()) {
        const char ch = ui_result_2[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_result_2.length()) break;
      // Newline.
      if (ui_result_2[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_result_3.length(); i++) {
      const char ch = ui_result_3[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 71;
    size_t i = 0;
    while (i <= ui_result_3.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_result_3.length()) {
        const char ch = ui_result_3[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 3;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_result_3.length()) {
        const char ch = ui_result_3[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_result_3.length()) break;
      // Newline.
      if (ui_result_3[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_result_4.length(); i++) {
      const char ch = ui_result_4[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 95;
    size_t i = 0;
    while (i <= ui_result_4.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_result_4.length()) {
        const char ch = ui_result_4[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 3;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_result_4.length()) {
        const char ch = ui_result_4[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_result_4.length()) break;
      // Newline.
      if (ui_result_4[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_results_prev_btn.length(); i++) {
      const char ch = ui_results_prev_btn[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    int cy = 117;
    size_t i = 0;
    while (i <= ui_results_prev_btn.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_results_prev_btn.length()) {
        const char ch = ui_results_prev_btn[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 2;
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_results_prev_btn.length()) {
        const char ch = ui_results_prev_btn[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_results_prev_btn.length()) break;
      // Newline.
      if (ui_results_prev_btn[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
}

// Screen 12: monitoring
inline void draw_monitoring_screen(Adafruit_SSD1327 &display) {
  display.clearDisplay();
  display.drawLine(0, 15, 127, 15, SSD1327_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(4, 3);
  display.print(F("MONITORING"));
  if (ui_right_eye) {
    display.drawLine(74, 104, 77, 108, SSD1327_WHITE);
    display.drawLine(77, 108, 83, 100, SSD1327_WHITE);
  }
  if (ui_left_eye) {
    display.drawLine(43, 99, 52, 108, SSD1327_WHITE);
    display.drawLine(52, 99, 43, 108, SSD1327_WHITE);
  }
  display.drawCircle(48, 104, 8, SSD1327_WHITE);
  display.drawCircle(79, 104, 8, SSD1327_WHITE);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(31, 100);
  display.print(F("L"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(93, 100);
  display.print(F("R"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  display.setCursor(9, 117);
  display.print(F("Position:"));
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(SSD1327_WHITE);
  {
    const int line_h = 8 * 1;
    int lines_n = 1;
    for (size_t i = 0; i < ui_text_el_269.length(); i++) {
      const char ch = ui_text_el_269[i];
      if (ch == '\r') continue;
      if (ch == '\n') { lines_n++; }
    }
    const int oy = max(0, (8 - (lines_n * line_h)) / 2);
    int cy = 117 + oy;
    size_t i = 0;
    while (i <= ui_text_el_269.length()) {
      // Count characters in this line (excluding \r).
      int cols = 0;
      size_t j = i;
      while (j < ui_text_el_269.length()) {
        const char ch = ui_text_el_269[j];
        if (ch == '\r') { j++; continue; }
        if (ch == '\n') break;
        cols++;
        j++;
      }
      const int x0 = 69 + max(0, (51 - (cols * 6 * 1)) / 2);
      display.setCursor(x0, cy);
      // Write this line.
      while (i < j && i < ui_text_el_269.length()) {
        const char ch = ui_text_el_269[i];
        if (ch != '\r') display.write(ch);
        i++;
      }
      // End of string.
      if (i >= ui_text_el_269.length()) break;
      // Newline.
      if (ui_text_el_269[i] == '\n') { i++; cy += line_h; continue; }
      // Safety: advance to avoid infinite loop.
      i++;
    }
  }
  display.drawRect(4, 21, 120, 72, SSD1327_WHITE);
  {
    const int gx = max(1, min(118, (int)ui_gaze_point.x));
    const int gy = max(1, min(70, (int)ui_gaze_point.y));
    display.fillRect(4 + gx - 1, 21 + gy - 1, 3, 3, SSD1327_WHITE);
  }
}

// Dispatcher: choose which screen to draw from your main loop.
inline void draw_screen(Adafruit_SSD1327 &display, UiScreen screen) {
  switch (screen) {
    case UiScreen::LOADING: draw_loading_screen(display); break;
    case UiScreen::BOOT: draw_boot_screen(display); break;
    case UiScreen::FIND_POSITION: draw_find_position_screen(display); break;
    case UiScreen::MOVE_CLOSER: draw_move_closer_screen(display); break;
    case UiScreen::MOVE_FARTHER: draw_move_farther_screen(display); break;
    case UiScreen::IN_POSITION: draw_in_position_screen(display); break;
    case UiScreen::CALIBRATION: draw_calibration_screen(display); break;
    case UiScreen::RECORD_CONFIRMATION: draw_record_confirmation_screen(display); break;
    case UiScreen::RECORDING: draw_recording_screen(display); break;
    case UiScreen::STOP_RECORD: draw_stop_record_screen(display); break;
    case UiScreen::INFERENCE_LOADING: draw_inference_loading_screen(display); break;
    case UiScreen::RESULTS: draw_results_screen(display); break;
    case UiScreen::MONITORING: draw_monitoring_screen(display); break;
    default: draw_loading_screen(display); break;
  }
}

// Optional: legacy index-based dispatcher (maps to UiScreen values).
inline void draw_screen(Adafruit_SSD1327 &display, uint8_t index) {
  draw_screen(display, static_cast<UiScreen>(index));
}
